import '../../aicr_cli.dart';
import 'markdown_builder.dart';
import 'shared_markdown_blocks.dart';

part 'pr_comment_builder/risk_level_calculator.dart';
part 'pr_comment_builder/overall_confidence_helper.dart';
part 'pr_comment_builder/review_decision_builder.dart';
part 'pr_comment_builder/top_actions_selector.dart';

/// Builder for PR comment markdown payload.
///
/// Takes an [AicrReport] and builds a markdown string suitable for PR comments.
/// Ensures stable ordering for deterministic output.
final class PrCommentBuilder {
  /// Builds the PR comment markdown body from the given report.
  String build(AicrReport report) {
    final md = MarkdownBuilder();

    final status = report.summary.status.name.toUpperCase();
    md.h2('AICR — $status');

    final riskLevel = _risk().calculate(report);
    final overallConfidence = _confidence().calculate(report);
    final overallConfidenceText = _confidence().format(overallConfidence);

    // Header: repo, run id, AI mode
    _renderHeader(md, report, riskLevel, overallConfidenceText);

    // Summary: risk level + confidence
    // (already included in header via SharedMarkdownBlocks)

    // Tables: signals
    _renderSignalsTable(md, report);

    // Sections:
    // - Review recommended
    _renderReviewRecommended(md, report, overallConfidence);

    // - Top actions (limit 5)
    _renderTopActions(md, report);

    // - AI findings (if any)
    _renderAiFindings(md, report);

    // - Deterministic findings (grouped)
    _renderDeterministicFindings(md, report);

    // Footer: diff hash + generated by AICR
    _renderFooter(md, report);

    return md.toString().trimRight();
  }

  void _renderHeader(
    MarkdownBuilder md,
    AicrReport report,
    String riskLevel,
    String overallConfidenceText,
  ) {
    SharedMarkdownBlocks.metaHeaderBlock(md, report);
    SharedMarkdownBlocks.riskConfidenceSummaryBlock(
      md,
      riskLevel: riskLevel,
      overallConfidenceText: overallConfidenceText,
    );
    _renderCiInfo(md, report);
  }

  void _renderCiInfo(MarkdownBuilder md, AicrReport report) {
    final ci = report.meta.ci;
    if (ci == null) return;

    md.p(
      '**CI:** postComment=${ci.postComment} · mode=${ci.commentMode} · marker=${ci.marker}',
    );
  }

  void _renderSignalsTable(MarkdownBuilder md, AicrReport report) {
    final aiCount = report.findings.where(_isAi).length;
    SharedMarkdownBlocks.signalsTableBlock(md, report, aiCount: aiCount);
  }

  void _renderReviewRecommended(
    MarkdownBuilder md,
    AicrReport report,
    double overallConfidence,
  ) {
    md.h3('Review recommended');
    final conf = _confidence();
    final decisionBuilder = _ReviewDecisionBuilder(
      aiCount: (report) => report.findings.where(_isAi).length,
      confidence: conf,
      isAi: _isAi,
    );
    final decisionText = decisionBuilder.build(
      report,
      overallConfidence: overallConfidence,
    );
    md.p(decisionText);
  }

  void _renderTopActions(MarkdownBuilder md, AicrReport report) {
    final top = _topActions().select(report, limit: 5);
    if (top.isEmpty) return;

    md.h3('Top actions');
    for (final f in top) {
      final tag = _isAi(f) ? '[ai${_confTag(f)}]' : '[det]';
      md.bullet('**${f.title}** $tag — ${_msg(f)}');
    }
    md.nl();
  }

  void _renderAiFindings(MarkdownBuilder md, AicrReport report) {
    final aiFindings = report.findings
        .where(_isAi)
        .toList()
      ..sort(_stableSort);

    if (aiFindings.isEmpty) return;

    md.h3('AI findings');
    final grouped = _groupByCategory(aiFindings);

    for (final entry in _sortedCategoryEntries(grouped)) {
      md.p('**${entry.key.name}**');

      final items = entry.value..sort(_stableSort);

      for (final f in items) {
        final tag = '[ai${_confTag(f)}]';
        md.bullet(
          '`${f.severity.name}` **${f.title}** $tag — ${_msg(f)}',
        );
      }
      md.nl();
    }
  }

  void _renderDeterministicFindings(MarkdownBuilder md, AicrReport report) {
    final detFindings = report.findings
        .where((f) => !_isAi(f))
        .toList()
      ..sort(_stableSort);

    if (detFindings.isEmpty) return;

    md.h3('Deterministic findings');
    final grouped = _groupByCategory(detFindings);

    for (final entry in _sortedCategoryEntries(grouped)) {
      md.p('**${entry.key.name}**');

      final items = entry.value..sort(_stableSort);

      for (final f in items) {
        md.bullet(
          '`${f.severity.name}` **${f.title}** [det] — ${_msg(f)}',
        );
      }
      md.nl();
    }
  }

  void _renderFooter(MarkdownBuilder md, AicrReport report) {
    final diffHashShort = report.meta.diffHash.length > 12
        ? report.meta.diffHash.substring(0, 12)
        : report.meta.diffHash;
    md.p('**Diff hash:** `$diffHashShort` · Generated by AICR');
  }

  // Helper methods

  bool _isAi(AicrFinding f) => f.source == AicrFindingSource.ai;

  String _confTag(AicrFinding f) =>
      f.confidence == null ? '' : ',${(f.confidence! * 100).round()}%';

  String _msg(AicrFinding f) => f.messageEn;

  int _sevRank(AicrSeverity s) => switch (s) {
        AicrSeverity.critical => 4,
        AicrSeverity.warning => 3,
        AicrSeverity.suggestion => 2,
        AicrSeverity.info => 1,
      };

  /// Stable sort comparator for findings.
  /// Sorts by: severity (desc), confidence (desc if present), id (asc for stability).
  int _stableSort(AicrFinding a, AicrFinding b) {
    final sa = _sevRank(a.severity);
    final sb = _sevRank(b.severity);
    if (sa != sb) return sb.compareTo(sa);

    final ca = a.confidence ?? 0.0;
    final cb = b.confidence ?? 0.0;
    if (ca != cb) return cb.compareTo(ca);

    return a.id.compareTo(b.id);
  }

  Map<AicrCategory, List<AicrFinding>> _groupByCategory(
    List<AicrFinding> findings,
  ) {
    final m = <AicrCategory, List<AicrFinding>>{};
    for (final f in findings) {
      (m[f.category] ??= <AicrFinding>[]).add(f);
    }
    return m;
  }

  /// Returns category entries sorted by category name for stable ordering.
  List<MapEntry<AicrCategory, List<AicrFinding>>> _sortedCategoryEntries(
    Map<AicrCategory, List<AicrFinding>> grouped,
  ) {
    return grouped.entries.toList()
      ..sort((a, b) => a.key.name.compareTo(b.key.name));
  }

  _RiskLevelCalculator _risk() => _RiskLevelCalculator(sevRank: _sevRank);

  _OverallConfidenceHelper _confidence() =>
      _OverallConfidenceHelper(isAi: _isAi, sevRank: _sevRank);

  _TopActionsSelector _topActions() =>
      _TopActionsSelector(isAi: _isAi, sevRank: _sevRank);
}

